# Instruction Verification DSL

## Overview

A Domain-Specific Language (DSL) for verifying compiler-generated bytecode instructions in test cases. The DSL provides a concise, readable format for specifying expected instruction sequences, constant tables, and module structures.

## Goals

- **Reduce verbosity**: Replace 10-20 lines of C++ verification code with 1-2 lines per instruction
- **Improve readability**: Self-documenting format that resembles disassembly output
- **Comprehensive verification**: Support for instructions, constants, exports, globals, types, and upvalues
- **Easy maintenance**: Clear error messages when verification fails

## Basic Syntax

### Section Format and Alignment Rules

A DSL specification consists of multiple sections. Each section has a header and contains multiple rows.

**Section Structure:**
```
[SectionName]
<row 1>
<row 2>
...
```

**Row Structure:**

Each row is divided into:
1. **Row Header**: An identifier/index (e.g., `0:`, `K[0]:`, `E[0]:`, `U[0]:`)
2. **Row Content**: One or more columns of data

**Alignment Rules:**

Within a single section, all rows must follow these alignment rules:

1. **Row headers** do not need consistent width (variable width based on index)
2. **First column** of row content starts at the same position for all rows in the section
3. **Subsequent columns** within row content are aligned across all rows
4. Columns are separated by at least one space
5. Alignment width is determined by the widest content in each column within that section

**Example:**
```
[Instructions]
0:  OP_LOAD_CONSTANT        A=0x00 K=0x0000 i=F s=F
1:  OP_ITER_NEXT            A=0xFF B=0x01 C=0x00 kb=F kc=F
10: OP_JUMP                 J=0x000007 s=T
```

Note: Row header width varies (`0:`, `1:`, `10:`), but first column (`OP_LOAD_CONSTANT`, etc.) aligns.

### Instruction Format

Instructions follow the general section format with specific column rules:

**Row Format:**
```
<pc>: <OPCODE> <operands...>
```

**Operand formats by instruction type:**

- **K-type**: `A=0x00 K=0x0000 [i=T/F] [s=T/F]`
- **T-type**: `A=0x00 B=0x00 C=0x00 [kb=T/F] [kc=T/F]`
- **J-type**: `J=0x000000 [s=T/F]`

**Field naming:**
- `A`, `B`, `C`: Register operands (8-bit, hex: `0x00` to `0xFF`)
- `K`: Constant index (16-bit, hex: `0x0000` to `0xFFFF`)
- `J`: Jump offset (24-bit, hex: `0x000000` to `0xFFFFFF`)
- `i`, `s`, `kb`, `kc`: Boolean flags (`T` for true, `F` for false)

## Section Types

### [Instructions]

Main module instruction sequence.

```
[Instructions]
0: OP_DEFER_CALL    A=0x00 K=0x0000 i=F s=F
1: OP_RETURN        A=0xFF B=0x00 C=0x00 kb=F kc=F
```

### [Instructions:label]

Named function instruction sequence.

```
[Instructions:testFunc]
0: OP_LOAD_INLINE_INTEGER   A=0x00 K=0x0005 i=T s=T
1: OP_RETURN                A=0x00 B=0x00 C=0x00 kb=F kc=F
```

### [Constants]

Constant table entries with type-specific properties.

**Row Format:**
```
K[<index>]: <TypeName> <properties...>
```

Type names form the first column and are aligned within the section. Properties form subsequent columns.

**Example:**
```
[Constants]
K[0]:  Int             42
K[1]:  Float           3.14
K[3]:  String          "hello" length=5
K[4]:  String          "世界" length=2
K[5]:  Range           start=0 end=10 step=1
K[6]:  FunctionProto   arity=2 coarity=1 maxStackSize=10 -> @myFunc
K[7]:  String          "He said \"hello\"" length=14
```

**Supported constant types:**

- `Int <value>`: Integer constant
- `Float <value>`: Floating-point constant
- `String "<text>" length=<num>`: String constant (use `\"` for embedded quotes)
- `Range start=<num> end=<num> step=<num>`: Range object
- `FunctionProto arity=<num> coarity=<num> maxStackSize=<num> [-> @label]`: Function prototype (maxStackSize specifies the maximum stack size needed by the function)

### [UpvalueDescription:label]

Upvalue capture information for a specific function.

**Row Format:**
```
U[<slot>]: index=<num> isLocal=<T/F>
```

**Example:**
```
[UpvalueDescription:testFunc]
U[0]: index=1 isLocal=T
U[1]: index=0 isLocal=F
```

- `U[n]`: Upvalue slot (0-255)
- `index`: Register or upvalue index being captured (0-255)
- `isLocal`: `T` if capturing a local variable, `F` if capturing from parent's upvalue

### [Exports]

Module exported variables by index.

**Row Format:**
```
E[<index>]: <identifier>
```

**Example:**
```
[Exports]
E[0]: test
E[1]: myFunction
E[2]: PI
```

The index corresponds to `ModuleVariableId` in the module's exports dictionary.

### [Globals]

Module global (non-exported) variables by index.

**Row Format:**
```
G[<index>]: <identifier>
```

**Example:**
```
[Globals]
G[0]: _internal
G[1]: _cache
```

The index corresponds to `ModuleVariableId` in the module's globals dictionary.

### [Types]

Custom type definitions by TypeId.

**Row Format:**
```
T[<typeId>]: <typeName>
```

**Example:**
```
[Types]
T[0]: Person
T[1]: Animal
T[2]: Vehicle
```

Maps type names to their `TypeId` (0-65535).

### [PreDefine:ModuleVariables]

Pre-initialize module variables before parsing (used in tests that need pre-existing state).

**Row Format:**
```
<identifier>: <Type> <value>
```

**Example:**
```
[PreDefine:ModuleVariables]
counter: Int 0
name:    String "test"
```

### [PreDefine:GlobalVariables]

Pre-initialize global variables before parsing.

**Row Format:**
```
<identifier>: <Type> <value>
```

**Example:**
```
[PreDefine:GlobalVariables]
PI:    Float 3.14159
DEBUG: Bool true
```

### [PreDefine:Registers]

Pre-initialize VM registers before executing (used by Module Builder).

**Row Format:**
```
R[<index>]: <Type> <value>
```

**Example:**
```
[PreDefine:Registers]
R[0]: Int 42
R[1]: Float 3.14
R[2]: String "hello"
```

Supported types: `Int`, `Float`, `Bool`, `String`

### [ModuleInit]

Specify metadata for the module initialization function (used by Module Builder to configure the moduleInit FunctionProto fields).

**Row Format:**
```
arity=<N> coarity=<N> maxStackSize=<N>
```

**Example:**
```
[ModuleInit]
arity=0 coarity=0 maxStackSize=10
```

**Notes:**
- This section configures the metadata for the module's main/initialization function
- For nested functions, their metadata (arity, coarity, maxStackSize) should be specified in the `[Constants]` section as part of their FunctionProto constant definition

## Complete Examples

### Example 1: Basic Defer Block

```cpp
TEST_F(CompilerDeferTest, BasicDeferBlockExactInstructions) {
    const char* source = "defer { a := 1 }";
    ErrorId result = ParseModule(source);
    EXPECT_EQ(result, 0);
    
    VerifyCompilation(module, R"(
[Instructions]
0: OP_DEFER_CALL    A=0x00 K=0x0000 i=F s=F
1: OP_RETURN        A=0xFF B=0x00 C=0x00 kb=F kc=F

[Constants]
K[0]: FunctionProto arity=0 coarity=0 maxStackSize=10 -> @deferFunc

[Instructions:deferFunc]
0: OP_LOAD_INLINE_INTEGER   A=0x00 K=0x0001 i=T s=T
1: OP_RETURN                A=0xFF B=0x00 C=0x00 kb=F kc=F
)");
}
```

### Example 2: Module with Exports and Types

```cpp
TEST_F(CompilerTest, ModuleWithExportsAndTypes) {
    const char* source = R"(
        export x := 42
        export fn test() -> Int { return 5 }
        
        class Person {
            name: String
            age: Int
        }
    )";
    
    VerifyCompilation(module, R"(
[Instructions]
0: OP_LOAD_INLINE_INTEGER   A=0x00 K=0x002A i=T s=T
1: OP_SET_MODULE_VAR        A=0x00 K=0x0000 i=F s=T
2: OP_LOAD_CONSTANT         A=0x00 K=0x0000 i=F s=F
3: OP_SET_MODULE_VAR        A=0x00 K=0x0001 i=F s=T
4: OP_RETURN                A=0xFF B=0x00 C=0x00 kb=F kc=F

[Constants]
K[0]: FunctionProto arity=0 coarity=1 maxStackSize=5 -> @testFunc

[Instructions:testFunc]
0: OP_LOAD_INLINE_INTEGER   A=0x00 K=0x0005 i=T s=T
1: OP_RETURN                A=0x00 B=0x00 C=0x00 kb=F kc=F

[Exports]
E[0]: x
E[1]: test

[Types]
T[0]: Person
)");
}
```

### Example 3: Function with Upvalues

```cpp
TEST_F(CompilerTest, FunctionWithUpvalues) {
    const char* source = R"(
        fn outer(x) {
            y := 10
            fn inner() {
                return x + y
            }
            return inner
        }
    )";
    
    VerifyCompilation(module, R"(
[Instructions]
0: OP_LOAD_CONSTANT         A=0x00 K=0x0000 i=F s=F
1: OP_SET_MODULE_VAR        A=0x00 K=0x0000 i=F s=F
2: OP_RETURN                A=0xFF B=0x00 C=0x00 kb=F kc=F

[Constants]
K[0]: FunctionProto arity=1 coarity=1 maxStackSize=10 -> @outerFunc
K[1]: FunctionProto arity=0 coarity=1 maxStackSize=8 -> @innerFunc

[Instructions:outerFunc]
0: OP_LOAD_INLINE_INTEGER   A=0x01 K=0x000A i=T s=T
1: OP_LOAD_CONSTANT         A=0x02 K=0x0001 i=F s=F
2: OP_CLOSE_UPVALUES        A=0x00 B=0x00 C=0x00 kb=F kc=F
3: OP_RETURN                A=0x02 B=0x00 C=0x00 kb=F kc=F

[UpvalueDescription:outerFunc]
U[0]: index=0 isLocal=T
U[1]: index=1 isLocal=T

[Instructions:innerFunc]
0: OP_GET_UPVALUE           A=0x00 B=0x00 C=0x00 kb=F kc=F
1: OP_GET_UPVALUE           A=0x01 B=0x01 C=0x00 kb=F kc=F
2: OP_ADD                   A=0x00 B=0x00 C=0x01 kb=F kc=F
3: OP_RETURN                A=0x00 B=0x00 C=0x00 kb=F kc=F

[UpvalueDescription:innerFunc]
U[0]: index=0 isLocal=F
U[1]: index=1 isLocal=F

[Exports]
E[0]: outer
)");
}
```

### Example 4: Nested For Loops

```cpp
TEST_F(CompilerForTest, NestedForLoops) {
    const char* source = "for i in 0..3 { for j in 0..2 { } }";
    
    VerifyCompilation(module, R"(
[Instructions]
0:  OP_LOAD_CONSTANT        A=0x00 K=0x0000 i=F s=F
1:  OP_ITER_NEXT            A=0xFF B=0x01 C=0x00 kb=F kc=F
2:  OP_JUMP                 J=0x000007 s=T
3:  OP_LOAD_CONSTANT        A=0x02 K=0x0001 i=F s=F
4:  OP_ITER_NEXT            A=0xFF B=0x03 C=0x02 kb=F kc=F
5:  OP_JUMP                 J=0x000002 s=T
6:  OP_JUMP                 J=0x000002 s=F
7:  OP_CLOSE_UPVALUES       A=0x02 B=0x00 C=0x00 kb=F kc=F
8:  OP_JUMP                 J=0x000007 s=F
9:  OP_CLOSE_UPVALUES       A=0x00 B=0x00 C=0x00 kb=F kc=F

[Constants]
K[0]: Range start=0 end=3 step=1
K[1]: Range start=0 end=2 step=1
)");
}
```

### Example 5: Using PreDefine

```cpp
TEST_F(CompilerGlobalVariableTest, GlobalVariableInExpression) {
    const char* source = "x := factor * 2";
    
    VerifyCompilation(module, R"(
[PreDefine:GlobalVariables]
factor: Int 10

[Instructions]
0: OP_LOAD_CONSTANT         A=0x00 K=0x0000 i=F s=T
1: OP_MULTIPLY              A=0x00 B=0x00 C=0x82 kb=F kc=T
)");
}
```

## API

### Main Verification Function

```cpp
void VerifyCompilation(SemiModule* module, const char* spec);
void VerifyCompilation(Compiler* compiler, const char* spec);
```

Parses and verifies the DSL specification against the compiled module or compiler state.

## Error Messages

When verification fails, the DSL provides concise error messages with section and index information:

```
Mismatch at [Instructions].(2):
  Expected: OP_JUMP J=0x000002 s=T
  Actual:   OP_JUMP J=0x000003 s=T

Mismatch at [Constants].(5):
  Expected: K[5]: Range start=0 end=10 step=1
  Actual:   K[5]: Range start=0 end=10 step=2

Missing entry at [Exports].(1):
  Expected: E[1]: myFunction
  Actual:   (not found)

Extra entry at [Globals].(3):
  Expected: (none)
  Actual:   G[3]: _unexpected
```

## Module Builder

The DSL can now be used in reverse: instead of verifying compiled modules, you can build modules from DSL specifications. This is useful for VM instruction tests where you want to set up specific bytecode scenarios without going through the compiler.

### API Functions

```cpp
// Build a module from DSL spec
SemiModule* BuildModule(SemiVM* vm, const char* spec);

// Build and run module in one call (for simple tests)
ErrorId BuildAndRunModule(SemiVM* vm, const char* spec, SemiModule** outModule = nullptr);
```

### Example: VM Instruction Test with Builder

```cpp
TEST_F(VMInstructionArithmeticTest, OpAddUsingBuilder) {
    ErrorId result = InstructionVerifier::BuildAndRunModule(vm, R"(
[PreDefine:Registers]
R[1]: Int 5
R[2]: Int 3

[FunctionMetadata]
arity=0 coarity=0 maxStackSize=3

[Instructions]
0: OP_ADD    A=0x00 B=0x01 C=0x02 kb=F kc=F
1: OP_TRAP   A=0x00 B=0x00 C=0x00 kb=F kc=F
)");

    ASSERT_EQ(result, 0);
    ASSERT_EQ(vm->values[0].as.i, 8);
}
```

## TODO

- [ ] Support for more complex constant types (nested functions, etc.)
- [ ] Round-trip validation (compile → DSL → build → verify)
